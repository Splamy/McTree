<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<link rel="icon" href="%sveltekit.assets%/favicon.png" />
	<script src="//d3js.org/d3.v5.min.js"></script>
	<script src="https://unpkg.com/@hpcc-js/wasm@0.3.11/dist/index.min.js"></script>
	<script src="https://unpkg.com/d3-graphviz@3.0.5/build/d3-graphviz.js"></script>
	<script src="https://dagrejs.github.io/project/graphlib/latest/graphlib.min.js"></script>
	<meta name="viewport" content="width=device-width" />

	<style>
		body {
			display: flex;
			flex-direction: row;
			height: 100vh;
			margin: 0;
		}

		#deps {
			height: 100vh;
			font-family: monospace;
			border: 1px solid black;
			min-width: 500px;
			height: calc(100% - 50px);
		}

		#graph {
			flex-grow: 1;
			height: 100%;
		}
	</style>
</head>

<body>
	<textarea id="deps"></textarea>
	<div id="graph" style="text-align: center;"></div>
</body>

<script>
	let diagram = undefined;
	let diag_x, diag_y;
	const deps_input = document.querySelector("#deps");
	deps_input.addEventListener("input", run);
	const elem_graph = document.querySelector("#graph");
	const render_debounced = debounce(render, 100);

	function run() {
		let ctx = parse(deps_input.value);
		get_flat_list(ctx);
		build_diagram(ctx);
		render_debounced();
	}

	function parse(input) {
		const ctx = {
			deps: new Map(),
			target: { name: "<x>", count: 0 },
			counts: new Map(),
		};

		const lines = input.split("\n");
		for (let i = 0; i < lines.length; i++) {
			const line = lines[i];

			const matchRule = line.match(/^\s*((?<TargetCount>[\d\.]+)\s*\*\s*)?(?<Target>\w+)\s*<-?\s*((?<IngridCount>[\d\.]+)\s*\*\s*)?(?<Ingrid>\w+)/);
			if (matchRule) {
				let target = matchRule.groups.Target;
				let count = NumOr1(matchRule.groups.IngridCount) / NumOr1(matchRule.groups.TargetCount);
				let ingrid = matchRule.groups.Ingrid;

				let deplist = ctx.deps.get(target);
				if (deplist == undefined) {
					deplist = new Map();
					ctx.deps.set(target, deplist);
				}

				let existing = deplist.get(ingrid) || 0;
				deplist.set(ingrid, existing + count);
				continue;
			}

			const matchStart = line.match(/^\s*=\s*((?<TargetCount>[\d\.]+)\s*\*\s*)?(?<Target>\w+)/);
			if (matchStart) {
				let target = matchStart.groups.Target;
				let count = NumOr1(matchStart.groups.TargetCount);

				ctx.target = { name: target, count };
				let existing = ctx.counts.get(target) || 0;
				ctx.counts.set(target, existing + count);
				continue;
			}

			const matchSub = line.match(/^\s*-\s*((?<TargetCount>[\d\.]+)\s*\*\s*)?(?<Target>\w+)/);
			if (matchSub) {
				let target = matchSub.groups.Target;
				let count = matchSub.groups.TargetCount;

				count = Number(count);
				if (isNaN(count)) {
					continue;
				}

				let existing = ctx.counts.get(target) || 0;
				ctx.counts.set(target, existing - count);
				continue;
			}
		}

		// console.log(deps);
		return ctx;
	}

	function get_flat_list(ctx) {
		const g = new graphlib.Graph({ multigraph: false, compound: false });

		for (const [target, deplist] of ctx.deps) {
			for (const [ingrid, count] of deplist) {
				g.setEdge(target, ingrid);
			}
		}

		let toplist = graphlib.alg.topsort(g);
		// console.log(toplist);


		for (let group of graphlib.alg.components(g)) {
			if (group.includes(ctx.target.name)) {
				group = new Set(group);
				ctx.group = group;
				toplist = toplist.filter((x) => group.has(x));
				break;
			}
		}

		ctx.group = ctx.group ?? new Set();

		// console.log(toplist);

		for (let item of toplist) {
			const itemdeps = ctx.deps.get(item);
			if (itemdeps == undefined) {
				continue;
			}

			let selfcount = Math.max(ctx.counts.get(item) || 0, 0);

			for (const [ingrid, count] of itemdeps) {
				const existing = ctx.counts.get(ingrid) || 0;
				ctx.counts.set(ingrid, existing + selfcount * count);
			}
		}
	}

	function build_diagram(ctx) {
		let digraph = "digraph {\n";

		console.log(ctx);

		for (const [ingrid, count] of ctx.counts) {
			if (count <= 0) {
				continue;
			}

			const countRound = Math.ceil(count);
			digraph += `  ${ingrid} [label="${ingrid} (${countRound})"];\n`;
		}

		digraph += "\n";

		for (const [target, deplist] of ctx.deps) {
			const targetCount = (ctx.counts.get(target) || 0);
			if (targetCount <= 0) {
				continue;
			}

			for (const [ingrid, count] of deplist) {
				if ((ctx.counts.get(ingrid) || 0) <= 0) {
					continue;
				}

				const partCount = targetCount * count;
				const countRound = parseFloat(partCount.toFixed(2));
				digraph += `  ${ingrid} -> ${target} [label="${countRound}"];\n`;
			}
		}

		digraph += "}";

		//console.log(digraph);
		diagram = digraph;
	}

	function render() {
		if (diagram == undefined) {
			return;
		}

		d3.select("#graph")
			.graphviz({
				width: "100%",
				height: "100%",
				fit: true,
			})
			.renderDot(diagram);
	}

	function debounce(func, timeout = 300) {
		let timer;
		return (...args) => {
			clearTimeout(timer);
			timer = setTimeout(() => { func.apply(this, args); }, timeout);
		};
	}

	function NumOr1(val) {
		const num = Number(val);
		if (isNaN(num)) {
			return 1;
		}
		return num;
	}

	run();
</script>

</html>
